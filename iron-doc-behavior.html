<script>
  (function() {

    // TODO(justinfagnani): rename, since this sounds like it renders a behavior
    Polymer.IronDocBehavior = {

      properties: {
        /**
         * The [Hydrolysis](https://github.com/PolymerLabs/hydrolysis)-generated
         * element descriptor to display details for.
         *
         * Alternatively, the element descriptor can be provided as JSON via the text content
         * of this element.
         *
         * @type {hydrolysis.ElementDescriptor}
         */
        descriptor: {
          type: Object,
        },

        /** The base href where this doc viewer is located */
        baseHref: {
          type: String,
          value: ''
        },

        /**
         * Prefix for fragment identifiers used in anchors.
         * For static routing `iron-component-page` can
         * set this to a string identifying the current component.
         */
        prefix: {
          type: String,
          value: ''
        },

        /** Whether private properties should be hidden or shown. */
        _showPrivate: {
          type:     Boolean,
          value:    false,
        },

        /** The label to show for the Private API toggle. */
        _privateToggleLabel: String,
      },

      ready: function() {
        var jsonDescriptor = this._loadJson();
        // Note that this is only an error during element creation. You are free
        // to stomp over the descriptor after it is ready.
        if (jsonDescriptor && this.descriptor) {
          Polymer.Base._error(
              this,
              'received both a bound descriptor:', this.descriptor,
              'and JSON descriptor:', this._jsonDescriptor,
              'Please provide only one');
          throw new Error(
              '<iron-doc-viewer> accepts either a bound or JSON descriptor; not both');
        }

        if (jsonDescriptor) {
          this.descriptor = jsonDescriptor;
        }
      },

      /**
       * Loads a hydrolysis element descriptor (as JSON) from the text content of
       * this element, if present.
       *
       * @return {hydrolysis.ElementDescriptor} The parsed descriptor, or `null`.
       */
      _loadJson: function() {
        var textContent = '';
        Array.prototype.forEach.call(Polymer.dom(this).childNodes, function(node) {
          textContent = textContent + node.textContent;
        });
        textContent = textContent.trim();
        if (textContent === '') return null;

        try {
          return JSON.parse(textContent);
        } catch(error) {
          Polymer.Base._error('Failure when parsing JSON:', textContent, error);
          throw error;
        }
      },

      _filterPrivate: function(items, showPrivate) {
        return items.filter(function(i) {
          return showPrivate || !(i.privacy === 'private' || i.privacy === 'protected');
        });
      },

      _noneToShow: function(showPrivate, descriptor, name) {
        var items = descriptor[name];
        if (showPrivate === undefined || items === undefined || items.length === 0) {
          return true;
        }

        for (var i = 0; i < items.length; i++) {
          if (showPrivate || !items[i].private) return false;
        }
        return true;
      },

      _formatAnchor: function(prefix, type, membername) {
        var suffix = membername ? '-' + membername : '';
        return prefix + type + suffix;
      },

      _getElementName: function(element) {
        var name = '';
        if (element.tagname) {
          name += '<' + element.tagname + '>';
          if (element.classname) {
            name += ' (' + element.classname + ')';
          }
        } else if (element.classname) {
          name += element.classname;
        }
        return name;
      },

      _getNamespaceName: function(name) {
        if (name == null) {
          return undefined;
        }
        var lastDotIndex = name.lastIndexOf('.');
        if (lastDotIndex === -1) {
          return undefined;
        }
        return name.substring(0, lastDotIndex);
      },

      _getName: function(name) {
        if (name == null) {
          return undefined;
        }
        var lastDotIndex = name.lastIndexOf('.');
        if (lastDotIndex === -1) {
          return name;
        }
        return name.substring(lastDotIndex, name.length);
      },

      _getElementId: function(element) {
        return element.classname || element.tagname;
      },

      _compareElements: function(a, b) {
        if (a.tagname === b.tagname) {
          return a.classname == null ? -1 : a.classname.localeCompare(b.classname);
        }
        return a.tagname == null ? -1 : b.tagname == null ? 1 : a.tagname.localeCompare(b.tagname);
      },

    };

  })();
</script>
