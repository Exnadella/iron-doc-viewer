<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../iron-location/iron-location.html">
<link rel="import" href="../marked-element/marked-element.html">
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../prism-element/prism-highlighter.html">
<link rel="import" href="../prism-element/prism-theme-default.html">

<link rel="import" href="iron-doc-behavior.html">
<link rel="import" href="iron-doc-class.html">
<link rel="import" href="iron-doc-element.html">
<link rel="import" href="iron-doc-mixin.html">
<link rel="import" href="iron-doc-namespace.html">
<link rel="import" href="iron-doc-viewer-behavior.html">

<!--
`iron-doc-viewer` renders documentation about elements, mixins, classes, and
more from the JSON descriptor output of
[Polymer Analyzer](https://github.com/Polymer/polymer-analyzer).

Provide the descriptor JSON either as a data binding to `descriptor`:

    <iron-doc-viewer descriptor="[[descriptor]]"></iron-doc-viewer>

or as child text content:

    <iron-doc-viewer>
      {
        "elements": [
          {
            "name": "my-component",
            "descriptor": "I'm a Web Component."
          }
        ]
      }
    </iron-doc-viewer>

`iron-doc-viewer` will initially display all items contained in the given
descriptor (e.g. elements, mixins, classes). `path` is used to display detail
about specific items within the descriptor (e.g. "/elements/my-component"), and
by default is bound to the current `window.location` path.

@demo demo/index.html
-->

<dom-module id="iron-doc-viewer">
  <template>
    <style include="iron-doc-viewer-styles prism-theme-default"></style>

    <template is="dom-if" if="[[!_pathSetExternally]]" restamp>
      <iron-location path="{{_ourPath}}"></iron-location>
    </template>

    <template is="dom-if" if="[[_equal(_descriptorType,'namespaces')]]" restamp>
      <iron-doc-namespace
          descriptor="[[_currentDescriptor]]"
          fragment-prefix="[[fragmentPrefix]]"
          base-href="[[baseHref]]">
      </iron-doc-namespace>
    </template>

    <template is="dom-if" if="[[_equal(_descriptorType,'elements')]]" restamp>
      <iron-doc-element
          descriptor="[[_currentDescriptor]]"
          fragment-prefix="[[fragmentPrefix]]"
          base-href="[[baseHref]]">
      </iron-doc-element>
    </template>

    <template is="dom-if" if="[[_equal(_descriptorType,'mixins')]]" restamp>
      <iron-doc-mixin
          descriptor="[[_currentDescriptor]]"
          fragment-prefix="[[fragmentPrefix]]"
          base-href="[[baseHref]]">
      </iron-doc-mixin>
    </template>

    <template is="dom-if" if="[[_equal(_descriptorType,'behaviors')]]" restamp>
      <iron-doc-behavior
          descriptor="[[_currentDescriptor]]"
          fragment-prefix="[[fragmentPrefix]]"
          base-href="[[baseHref]]">
      </iron-doc-behavior>
    </template>

    <template is="dom-if" if="[[_equal(_descriptorType,'classes')]]" restamp>
      <iron-doc-class
          descriptor="[[_currentDescriptor]]"
          fragment-prefix="[[fragmentPrefix]]"
          base-href="[[baseHref]]">
      </iron-doc-class>
    </template>
  </template>

  <script>
    (function() {
      Polymer({
        is: 'iron-doc-viewer',

        behaviors: [Polymer.IronDocViewerBehavior],

        properties: {
          /**
           * Path to the item in the descriptor to display.
           *
           * Examples:
           *   - `/` for the root namespace
           *   - `/elements/paper-button`
           *   - `/mixins/paper-button-behavior`
           *
           * Defaults to the current `window.location` path.
           *
           * If `baseHref` is set, it will be trimmed from the prefix of this
           * `path`.
           */
          path: {
            type: String,
            value: null
          },

          /**
           * Instead of displaying items relative to the top level of
           * `descriptor`, start from this namespace.
           */
          rootNamespace: {
            type: String,
          },

          _descriptorType: String,

          _pathSetExternally: {
            type: Boolean,
            value: false
          },

          _ourPath: String,

          _ourPathChanging: Boolean,

          _currentDescriptor: Object,
        },

        observers: [
          '_pathChanged(path)',
          '_ourPathChanged(_ourPath)',
          '_dataChanged(descriptor, path)'
        ],

        _equal: function(a, b) {
          return a == b;
        },

        _pathChanged: function(path) {
          this._pathSetExternally = path && !this._ourPathChanging;
        },

        _ourPathChanged: function(ourPath) {
          if (ourPath) {
            // Prevent cycles updating internal/external paths.
            this._ourPathChanging = true;
            this.path = ourPath;
            this._ourPathChanging = false;
          }
        },

        _dataChanged: function(descriptor, path) {
          var descriptorType, name;
          if (path) {
            if (this.baseHref && path.indexOf(this.baseHref) >= 0) {
              path = path.substring(this.baseHref.length);
            }
            var parts = path.split('/');
            if (parts.length > 1) {
              [, descriptorType, name] = parts;
            }
          }
          if (!this.descriptor) {
            return;
          }

          if (!descriptorType) {
            // If we don't have a route, display either the top-level namespace
            // or the rootNamespace if set.
            this._descriptorType = 'namespaces';
            if (this.rootNamespace && descriptor.namespaces) {
              var matches = descriptor.namespaces.filter((n) => n.name === this.rootNamespace);
              if (matches && matches.length > 0) {
                this._currentDescriptor = matches[0];
              }
              return;
            }
            this._currentDescriptor = descriptor;
            return;
          }

          var namespace = getNamespace(this.descriptor, name) || this.descriptor;
          if (namespace == null) {
            // 404?
            return;
          }
          this._descriptorType = descriptorType;
          if (descriptorType === 'namespaces') {
            this._currentDescriptor = namespace.namespaces &&
                namespace.namespaces.filter((n) => n.name === name)[0];
          } else if (descriptorType === 'elements') {
            this._currentDescriptor = namespace.elements &&
                namespace.elements.filter((e) => (e.name || e.tagname) === name)[0];
          } else if (descriptorType === 'classes') {
            this._currentDescriptor = namespace.classes &&
                namespace.classes.filter((e) => (e.name || e.tagname) === name)[0];
          } else if (descriptorType === 'mixins') {
            this._currentDescriptor = namespace.mixins &&
                namespace.mixins.filter((m) => m.name === name)[0];
          } else if (descriptorType === 'behaviors') {
            this._currentDescriptor =
              this._getPolymerBehaviors(namespace).filter((b) => b.name === name)[0];
          } else if (descriptorType === 'functions') {
            this._currentDescriptor = namespace.functions &&
                namespace.functions.filter((f) => f.name === name)[0];
          }
        },
      });

      /**
       * Walks through the tree of namespaces to find the namespace containing
       * `name`.
       */
      function getNamespace(descriptor, name) {
        var parts = name.split('.');
        if (parts.length < 2) {
          return undefined;
        }
        parts = parts.slice(0, parts.length - 1);
        var namespace = descriptor;

        for (var part of parts) {
          if (!namespace.namespaces) {
            return undefined;
          }
          var matches = namespace.namespaces.filter((n) => n.name === part);
          if (matches.length === 0) {
            return undefined;
          }
          namespace = matches[0];
        }
        return namespace;
      }
    })();
  </script>
</dom-module>
